<h1>API</h1>

<section>
  <h2>LazyElementDirective</h2>
  <code color="accent">Directive</code>
  <br />
  <p>
    A structural directive which lazy loads desired Angular element (or any
    other webcomponent)
  </p>
  <mat-card>
    <table>
      <thead>
        <th>Property</th>
        <th>Description</th>
      </thead>
      <tbody>
        <tr>
          <td><pre>selector</pre></td>
          <td>
            <p>
              The selector is <code>axLazyElement</code> which should be used
              with <code>*</code> as in <code>*axLazyElement</code> because it
              is a structural directive.
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <pre>
&#64;Input('axLazyElement')
url: string;</pre
            >
          </td>
          <td>
            <p>
              The url of the element bundle (or module). This is the main
              property which corresponds to the main directive selector.
            </p>
            <ul>
              <li>
                Inline string value -
                <code
                  >&#60;some-element
                  *axLazyElement="'https://elements.com/some-element'">&#60;/some-element></code
                >
              </li>
              <li>
                Component property reference -
                <code
                  >&#60;some-element
                  *axLazyElement="url">&#60;/some-element></code
                >
              </li>
              <code color="accent">Pre-configurable</code>
            </ul>
          </td>
        </tr>
        <tr>
          <td>
            <pre>
&#64;Input('axLazyElementLoadingTemplate')
loadingTemplateRef: TemplateRef&#60;any>;</pre
            >
          </td>
          <td>
            <p>
              Reference to Angular template which will be displayed before the
              element bundle (or module) was loaded. To show loader we can
              create following template
              <code
                >&#60;ng-template #loading>Loading...&#60;/ng-template></code
              >
              and then we have to reference it
              <code
                >&#60;some-element *axLazyElement="url; loadingTemplate:
                loading">&#60;/some-element></code
              >
            </p>
            <code color="accent">Optional</code>&nbsp;<code color="accent"
              >Default: undefined</code
            >
          </td>
        </tr>
        <tr>
          <td>
            <pre>
&#64;Input('axLazyElementErrorTemplate')
errorTemplateRef: TemplateRef&#60;any>;</pre
            >
          </td>
          <td>
            <p>
              Reference to Angular template which will be displayed when the
              element bundle (or module) loading failed. To show error message
              we can create following template
              <code
                >&#60;ng-template #error>Loading
                failed...&#60;/ng-template></code
              >
              and then we have to reference it
              <code
                >&#60;some-element *axLazyElement="url; errorTemplate:
                error">&#60;/some-element></code
              >
            </p>
            <code color="accent">Optional</code>&nbsp;<code color="accent"
              >Default: undefined</code
            >
          </td>
        </tr>
        <tr>
          <td>
            <pre>
&#64;Input('axLazyElementModule')
isModule: boolean;</pre
            >
          </td>
          <td>
            <p>
              Flag that specifies if the element is loaded as bundle (default)
              or as module. This will influence the generated
              <code>&#60;script></code> tag which will get
              <code>type="module"</code> in case this flag was set to true. The
              flag can be set using
              <code
                >&#60;some-element *axLazyElement="url; module:
                true">&#60;/some-element></code
              >
            </p>
            <code color="accent">Optional</code>&nbsp;<code color="accent"
              >Default: false</code
            >
            <code color="accent">Pre-configurable</code>
          </td>
        </tr>
        <tr>
          <td>
            <pre>
&#64;Input('axLazyElementImportMap')
importMap: boolean;</pre
            >
          </td>
          <td>
            <p>
              Flag that specifies if the element url should be resolved using
              import maps. If set to true an instance of
              <a href="https://github.com/systemjs/systemjs" target="_blank"
                >SystemJS</a
              >
              needs to exist in the application. <code>System.resolve</code> is
              used in order to find the correct URL to load the bundle file
              containing the element definition. The flag can be set using
              <code
                >&#60;some-element *axLazyElement="url; importMap:
                true">&#60;/some-element></code
              >
            </p>
            <code color="accent">Optional</code>&nbsp;<code color="accent"
              >Default: false</code
            >
            <code color="accent">Pre-configurable</code>
          </td>
        </tr>
      </tbody>
    </table>
  </mat-card>
  <mat-card>
    <table>
      <thead>
        <th>Function</th>
        <th>Description</th>
      </thead>
      <tbody>
        <tr>
          <td>
            <pre>destroyEmbeddedView()</pre>
          </td>
          <td>
            <p>
              The <code>destroyEmbeddedView</code>
              is a public method which can be called by parent component to
              destroy element's embedded view on demand.
            </p>
          </td>
        </tr>
      </tbody>
    </table>
  </mat-card>
</section>

<section>
  <h2>LazyElementModule</h2>
  <code color="accent">Module</code>
  <br />
  <p>
    An Angular module which exports <code>*axLazyElement</code> and
    <code>*axLazyElementDynamic</code> directives so it has to be imported in
    other Angular modules which want to use these directives in the templates of
    their components. Module can be also pre-configured using
    <code>forRoot()</code> and <code>forFeature()</code> static methods.
  </p>
  <mat-card>
    <table>
      <thead>
        <th>Function</th>
        <th>Description</th>
      </thead>
      <tbody>
        <tr>
          <td><pre>forRoot(options: LazyElementModuleRootOptions)</pre></td>
          <td>
            <p>
              The <code>forRoot()</code> static method which accepts options of
              <code>LazyElementModuleRootOptions</code> type <br /><code
                color="accent"
                >Optional</code
              >
            </p>
          </td>
        </tr>
        <tr>
          <td><pre>forFeature(options: LazyElementModuleOptions)</pre></td>
          <td>
            <p>
              The <code>forFeature()</code> static method which accepts options
              of <code>LazyElementModuleOptions</code> type <br /><code
                color="accent"
                >Optional</code
              >
            </p>
          </td>
        </tr>
      </tbody>
    </table>
  </mat-card>
</section>

<section>
  <h2>LazyElementModuleRootOptions</h2>
  <code color="accent">Interface</code>
  <br />
  <p>
    Type of an option object that can be passed to static
    <code>forRoot()</code> method of <code>LazyElementModule</code>.
  </p>
  <mat-card>
    <table>
      <thead>
        <th>Property</th>
        <th>Description</th>
      </thead>
      <tbody>
        <tr>
          <td><pre>elementConfigs: ElementConfig[]</pre></td>
          <td>
            <p>
              Optional array of <code>ElementConfig</code>... <br />
              <code color="accent">Optional</code>&nbsp;<code color="accent"
                >Default: []</code
              >
            </p>
          </td>
        </tr>
        <tr>
          <td><pre>rootOptions: LazyElementRootOptions</pre></td>
          <td>
            <p>
              Optional object of <code>LazyElementRootOptions</code>... <br />
              <code color="accent">Optional</code>&nbsp;<code color="accent"
                >Default: &#123; &#125;</code
              >
            </p>
          </td>
        </tr>
      </tbody>
    </table>
  </mat-card>
</section>

<section>
  <h2>LazyElementRootOptions</h2>
  <code color="accent">Interface</code>
  <br />
  <p>
    Type of an option object that can be passed as the
    <code>rootOptions</code> of the
    <code>LazyElementModuleRootOptions</code> into the
    <code>forRoot()</code> method of <code>LazyElementModule</code>. These
    options will be applied to every element loaded using
    <code>*axLazyElement</code> or
    <code>*axLazyElementDynamic</code> directives. These options can be
    overridden by the element configuration in <code>forFeature()</code> and
    lastly by the inline configuration of <code>*axLazyElement</code> directive.
  </p>
  <mat-card>
    <table>
      <thead>
        <th>Property</th>
        <th>Description</th>
      </thead>
      <tbody>
        <tr>
          <td><pre>loadingComponent: Type&#60;any></pre></td>
          <td>
            <p>
              Component class to be displayed during element loading (similar to
              <code>loadingTemplate</code> that can be specified inline in the
              template, eg
              <code>*axLazyElement="url; loadingTemplate: loading;"</code>)
            </p>
            <code color="accent">Optional</code>&nbsp;<code color="accent"
              >Default: undefined</code
            >
          </td>
        </tr>
        <tr>
          <td><pre>errorComponent: Type&#60;any></pre></td>
          <td>
            <p>
              Component class to be displayed after element loading failed
              (similar to
              <code>errorTemplate</code> that can be specified inline in the
              template, eg
              <code>*axLazyElement="url; errorTemplate: error;"</code>)
            </p>
            <code color="accent">Optional</code>&nbsp;<code color="accent"
              >Default: undefined</code
            >
          </td>
        </tr>
        <tr>
          <td><pre>isModule: boolean</pre></td>
          <td>
            <p>
              Flag that specifies if the element is loaded as bundle (default)
              or as module. This will influence the generated
              <code>&#60;script></code> tag which will get
              <code>type="module"</code> in case this flag was set to true.
            </p>
            <code color="accent">Optional</code>&nbsp;<code color="accent"
              >Default: undefined</code
            >
          </td>
        </tr>
        <tr>
          <td><pre>importMap: boolean</pre></td>
          <td>
            <p>
              Flag that specifies if the element url should be resolved using
              import maps. If set to true an instance of
              <a href="https://github.com/systemjs/systemjs" target="_blank"
                >SystemJS</a
              >
              needs to exist in the application. <code>System.resolve</code> is
              used in order to find the correct URL to load the bundle file
              containing the element definition.
            </p>
            <code color="accent">Optional</code>&nbsp;<code color="accent"
              >Default: undefined</code
            >
          </td>
        </tr>
        <tr>
          <td><pre>preload: boolean</pre></td>
          <td>
            <p>
              Flag that specifies if the all the modules should be preloaded
            </p>
            <code color="accent">Optional</code>&nbsp;<code color="accent"
              >Default: undefined</code
            >
          </td>
        </tr>
        <tr>
          <td><pre>hooksConfig: HooksConfig</pre></td>
          <td>
            <p>
              Global hooks configuration for all elements. Any loaded element
              will run hooks configured here unless some of them were overriden
              in <code>ElementConfig</code>.
            </p>
            <code color="accent">Optional</code>&nbsp;<code color="accent"
              >Default: undefined</code
            >
          </td>
        </tr>
      </tbody>
    </table>
  </mat-card>
</section>

<section>
  <h2>LazyElementModuleOptions</h2>
  <code color="accent">Interface</code>
  <br />
  <p>
    Type of an option object that can be passed to static
    <code>forFeature()</code> method of <code>LazyElementModule</code>.
  </p>
  <mat-card>
    <table>
      <thead>
        <th>Property</th>
        <th>Description</th>
      </thead>
      <tbody>
        <tr>
          <td><pre>elementConfigs: ElementConfig[]</pre></td>
          <td>
            <p>
              Optional array of <code>ElementConfig</code>... <br />
              <code color="accent">Optional</code>&nbsp;<code color="accent"
                >Default: []</code
              >
            </p>
          </td>
        </tr>
      </tbody>
    </table>
  </mat-card>
</section>

<section>
  <h2>ElementConfig</h2>
  <code color="accent">Interface</code>
  <br />
  <p>
    The element config used to pre-configure <code>LazyElementModule</code> so
    that we do not have to specify url (and other supported options) inline
    inside of the <code>*axLazyElement</code> and
    <code>*axLazyElementDynamic</code> directives. The configs are matched to
    particular elements by the tag. The elements are still loaded lazily even
    though they are preconfigured in the module during application startup...
  </p>
  <mat-card>
    <table>
      <thead>
        <th>Property</th>
        <th>Description</th>
      </thead>
      <tbody>
        <tr>
          <td><pre>tag: string</pre></td>
          <td>
            <p>Tag of an element (eg: <code>some-element</code>)</p>
          </td>
        </tr>
        <tr>
          <td><pre>url: string</pre></td>
          <td>
            <p>
              The url of an element bundle or ES module (eg:
              <code>https://my-org.com/elements/some-element.js</code>)
            </p>
          </td>
        </tr>
        <tr>
          <td><pre>isModule: boolean</pre></td>
          <td>
            <p>
              Flag that specifies if the element is loaded as bundle (default)
              or as module. This will influence the generated
              <code>&#60;script></code> tag which will get
              <code>type="module"</code> in case this flag was set to true.
            </p>
            <code color="accent">Optional</code>&nbsp;<code color="accent"
              >Default: undefined</code
            >
          </td>
        </tr>
        <tr>
          <td><pre>importMap: boolean</pre></td>
          <td>
            <p>
              Flag that specifies if the element url should be resolved using
              import maps. If set to true an instance of
              <a href="https://github.com/systemjs/systemjs" target="_blank"
                >SystemJS</a
              >
              needs to exist in the application. <code>System.resolve</code> is
              used in order to find the correct URL to load the bundle file
              containing the element definition.
            </p>
            <code color="accent">Optional</code>&nbsp;<code color="accent"
              >Default: undefined</code
            >
          </td>
        </tr>
        <tr>
          <td><pre>loadingComponent: Type&#60;any></pre></td>
          <td>
            <p>
              Component class to be displayed during element loading (similar to
              <code>loadingTemplate</code> that can be specified inline in the
              template, eg
              <code>*axLazyElement="url; loadingTemplate: loading;"</code>)
            </p>
            <code color="accent">Optional</code>&nbsp;<code color="accent"
              >Default: undefined</code
            >
          </td>
        </tr>
        <tr>
          <td><pre>errorComponent: Type&#60;any></pre></td>
          <td>
            <p>
              Component class to be displayed after element loading failed
              (similar to
              <code>errorTemplate</code> that can be specified inline in the
              template, eg
              <code>*axLazyElement="url; errorTemplate: error;"</code>)
            </p>
            <code color="accent">Optional</code>&nbsp;<code color="accent"
              >Default: undefined</code
            >
          </td>
        </tr>
        <tr>
          <td><pre>preload: boolean</pre></td>
          <td>
            <p>Flag that specifies if the element is preloaded.</p>
            <code color="accent">Optional</code>&nbsp;<code color="accent"
              >Default: undefined</code
            >
          </td>
        </tr>
        <tr>
          <td><pre>hooks: HooksConfig</pre></td>
          <td>
            <p>
              Hooks configuration for the element. Any hook specified here will
              overwrite corresponding root hook for the element. See
              <code>HooksConfig</code>.
            </p>
            <code color="accent">Optional</code>&nbsp;<code color="accent"
              >Default: undefined</code
            >
          </td>
        </tr>
      </tbody>
    </table>
  </mat-card>
</section>

<section>
  <h2>HooksConfig</h2>
  <code color="accent">Interface</code>
  <br />
  <p>
    Hooks for running custom logic as part of the element's lifecycle. See
    <code>ElementConfig</code> and <code>LazyElementRootOptions</code>.
  </p>
  <mat-card>
    <table>
      <thead>
        <th>Property</th>
        <th>Description</th>
      </thead>
      <tbody>
        <tr>
          <td><pre>beforeLoad: Hook</pre></td>
          <td>
            <p>
              This hook will run before the browser starts the element's
              download. If the provided hook returns a <code>Promise</code> the
              element's download will be postponed until the Promise is
              resolved.
            </p>
            <code color="accent">Optional</code>&nbsp;<code color="accent"
              >Default: undefined</code
            >
          </td>
        </tr>
        <tr>
          <td><pre>afterLoad: Hook</pre></td>
          <td>
            <p>
              This hook will run after the element's download has been
              completed. If the provided hook returns a <code>Promise</code> the
              element's insertion into the corresponding Angular's view will be
              postponed until the Promise is resolved.
            </p>
            <code color="accent">Optional</code>&nbsp;<code color="accent"
              >Default: undefined</code
            >
          </td>
        </tr>
      </tbody>
    </table>
  </mat-card>
</section>

<section>
  <h2>Hook</h2>
  <code color="accent">Type</code>
  <br />
  <p>Hook that can be run as part of <code>HooksConfig</code>.</p>
  <mat-card>
    <table>
      <thead>
        <th>Value</th>
        <th>Description</th>
      </thead>
      <tbody>
        <tr>
          <td>
            <pre>
(tag: string) => Promise&lt;void&gt; &#x2758; &lt;void&gt;</pre
            >
          </td>
          <td>
            <p>
              Provided function will be called at the appropriate time in the
              element's lifecycle. If the function returns a
              <code>Promise</code> the library will wait for its' resolution
              before proceeding.
            </p>
          </td>
        </tr>
      </tbody>
    </table>
  </mat-card>
</section>

<section>
  <h2>LazyElementsLoaderService</h2>
  <code color="accent">Service</code>
  <br />
  <p>
    A service used for loading the Angular element (or any other webcomponent)
  </p>
  <mat-card>
    <table>
      <thead>
        <th>Method</th>
        <th>Description</th>
      </thead>
      <tbody>
        <tr>
          <td><pre>preload(tags? : string[]): void</pre></td>
          <td>
            <p>
              Preloads the specified tags which are preconfigured using
              <code>forRoot</code> and <code>forFeature</code>. If
              <code>tags</code> is <code>undefined|null</code> preload all the
              configured tags. <br />
              Parameters: <br />
              tags <code color="accent">Optional</code>&nbsp;<code
                color="accent"
                >Default: undefined</code
              ><br />
              returns: <code color="accent">void</code>
            </p>
          </td>
        </tr>
      </tbody>
    </table>
  </mat-card>
</section>

<section>
  <h2>LAZY_ELEMENTS_REGISTRY</h2>
  <code color="accent">Token</code>
  <br />
  <p>
    A token used to override default lazy elements registry which is used to
    prevent multiple downloads of the same element Javascript bundle...
  </p>
  <mat-card>
    <table>
      <thead>
        <th>Value</th>
        <th>Description</th>
      </thead>
      <tbody>
        <tr>
          <td>
            <pre>
&#123;
  provide: LAZY_ELEMENTS_REGISTRY,
  useClass: YourRegistryImplementation
&#125;</pre
            >
          </td>
          <td>
            <p>
              Overrides default lazy elements registry implementation which can
              be useful when using library in the multiple apps (or elements) on
              a single page to prevent multiple downloads of the same element
              Javascript bundle. The new implementation has to implement
              <code>LazyElementsRegistry</code>
            </p>
          </td>
        </tr>
      </tbody>
    </table>
  </mat-card>
</section>

<section>
  <h2>LazyElementsRegistry</h2>
  <code color="accent">Interface</code>
  <br />
  <p>
    An interface which has to be implemented by custom lazy elements registry.
    The default lazy element registry used by the library out of the box is
    <code>Map&lt;string, Promise&lt;void></code>
  </p>
  <mat-card>
    <table>
      <thead>
        <th>Property</th>
        <th>Description</th>
      </thead>
      <tbody>
        <tr>
          <td>
            <pre>get: (url: string) => Promise&lt;void></pre>
          </td>
          <td>
            <p>
              Retrieve loading state (<code>Promise</code>) of an element bundle
              identified by the <code>url</code>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <pre>set: (url: string, notifier: Promise&lt;void>) => void</pre>
          </td>
          <td>
            <p>
              Store loading state (<code>Promise</code>) of an element bundle
              identified by the <code>url</code>
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <pre>has: (url: string) => boolean</pre>
          </td>
          <td>
            <p>
              Check if registry already contains loading state
              (<code>Promise</code>) of an element bundle identified by the
              <code>url</code>
            </p>
          </td>
        </tr>
      </tbody>
    </table>
  </mat-card>
</section>

<section>
  <h2>LazyElementTestingModule</h2>
  <code color="accent">Module</code>
  <code>&#64;angular-extensions/elements/testing</code>
  <br />
  <p>
    The testing module is used in Angular unit-tests to help mock lazy-loaded
    elements with mock components provided by the test. Check out how to use it
    in the
    <a routerLink="/examples/testing">testing example</a>.
  </p>
  <mat-card>
    <table>
      <thead>
        <th>Declarable</th>
        <th>Description</th>
      </thead>
      <tbody>
        <tr>
          <td>
            <pre>LazyElementTestingDirective <code>*axLazyElement</code></pre>
          </td>
          <td>
            <p>
              Overrides default behavior of <code>*axLazyElement</code> by
              displaying element immediately without trying to lazy load it,
              display loading or error...
            </p>
          </td>
        </tr>
        <tr>
          <td>
            <pre>LazyElementDynamicTestingDirective <code>*axLazyElementDynamic</code></pre>
          </td>
          <td>
            <p>
              Overrides default behavior of
              <code>*axLazyElementDynamic</code> by displaying element
              immediately without trying to lazy load it, display loading or
              error...
            </p>
          </td>
        </tr>
      </tbody>
    </table>
  </mat-card>
</section>
